List Sort
=============

list.stream()
        .sorted(Compartor.comparing(x))
        .sorted(Compartor.comparing(x, Comparator.reverseOrder())
        .sorted(Compartor.comparing(x, Comparator.nullsLast(Comparator.naturalOrder()))
        .sorted(Compartor.comparing(x, Comparator.nullsLast(Comparator.reverseOrder()))
	    .sorted(Compartor.comparingInt(x))
        .sorted(Compartor.comparingInt(x, Comparator.reverseOrder()))
        .sorted(Compartor.comparing(x).thenComparing(y))
        .sorted(Compartor.comparing(x).thenComparing(y, Comparator.reverseOrder())
        .sorted(Compartor.comparing(x, Comparator.reverseOrder()).thenComparing(y, Comparator.reverseOrder())

    	.sorted(Comparator.reverseOrder()) //1 field
.toList();

Max
==================================================================

   //.max(Integer::compareTo), .max(Double::compareTo), .max(BigDecimal::compareTo)

    List<Integer> integerList = List.of(23, 34, 56,231, 36);
    Integer highestInt = integerList.stream().max(Integer::compareTo).get();

    List<Number> numberList = List.of(23.09f, 23L, 123.34d);
    Number highestNumber = numberList.stream().map(Number::doubleValue).max(Double::compareTo).get();

    List<Item> itemList = getItemsWithPrice();
    BigDecimal highestPrice = itemList.stream().map(Item::getPrice).max(BigDecimal::compareTo).orElse(null);

    //max(Comparator.comparing(Item::getPrice))
    String itemNoWithHighestPrice =
            itemList.stream().max(Comparator.comparing(Item::getPrice)).get().getItemNo();

Java 9
=============

Factory methods for collections
-------------------------------
List immutableList = List.of("Abc", "Def", "Ghi");
Map immutableMap = Map.of(1, "one", 2, "two", 3, "three");

Private Interface Methods
------------------------------
private static method (can be called from within Interface default/static methods)
private method        (can be called from within Interface default/private methods)

Reactive Streams
------------------------------
Asynchronous stream processing + backpressure

<!-- RxJava -->
    <dependency>
        <groupId>io.reactivex.rxjava3</groupId>
        <artifactId>rxjava</artifactId>
        <version>3.1.7</version>
    </dependency>

    String[] letters = {"a", "b", "c", "d", "e", "f", "g", "h", "i"};

    Observable.fromArray(letters)
    .map(String::toUpperCase)
    .subscribe(st -> System.out.println(st), //onNext
    Throwable::printStackTrace,      //onError
    () -> {});                       //onComplete
    // A B C D E F G H I

    Observable.fromArray(letters)
    .scan(new StringBuilder(), StringBuilder::append) //scan(R initialValue, accumulator)
    .subscribe(st -> System.out.println(st),
    Throwable::printStackTrace,
    () -> {});
    //a ab abc abcd abcde abcdef abcdefg abcdefgh abcdefghi

    Observable.fromArray(letters)
    .defaultIfEmpty("Observable is empty")
    .firstElement()
    .subscribe(st -> System.out.println(st),
    Throwable::printStackTrace,
    () -> {}); //a

    Integer[] numbers = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    Observable.fromArray(numbers)
    .groupBy(i -> i % 2 == 0 ? "EVEN" : "ODD")
    .subscribe(group -> group.subscribe((number) -> {
        System.out.print(number + "-" + group.getKey() + " ");
    },
    Throwable::printStackTrace,
    () -> {}
    ));
    //0-EVEN 1-ODD 2-EVEN 3-ODD 4-EVEN 5-ODD 6-EVEN 7-ODD 8-EVEN 9-ODD

    System.out.println();
    List<Integer> listEven = Observable.fromArray(numbers)
    .filter(i -> i%2==0)
    .collect(Collectors.toList()).blockingGet();
    System.out.println(listEven);
    //[0, 2, 4, 6, 8]

    List<Integer> firstFiveNos = Observable.fromArray(numbers)
    .takeWhile(i -> i<5)
    .collect(Collectors.toList()).blockingGet();
    System.out.println(firstFiveNos);
    //[0, 1, 2, 3, 4]

    String[] result = {""};
    ConnectableObservable<Long> connectableObservable = Observable.interval(200, TimeUnit.MILLISECONDS).publish();
    connectableObservable.subscribe(i -> result[0] += i);
    System.out.println(result[0]);

    connectableObservable.connect();
    Thread.sleep(500);

    System.out.println(result[0]); //01

    List<String> lettersString = Arrays.asList("a", "b", "c", "d", "e", "f", "g", "h", "i");
    Observable.fromIterable(lettersString)
    .map(String::toUpperCase)
    .subscribe(System.out::println);

    System.out.println("//------------------- fromIterable :: Custom function ----------------------------");

    Observable.fromIterable(lettersString)
    .map(s->updateLetter(s))
    .subscribe(System.out::println);

    System.out.println("//------------------- Cold Observable ----------------------------");

    Observable observable = Observable.create(source -> {
    source.onNext(Math.random());
    });
    observable.subscribe(System.out::println);
    observable.subscribe(System.out::println);

    System.out.println("//------------------- Hot Observable ----------------------------");

    var i = Math.random();
    Observable observable2 = Observable.create(source -> {
    source.onNext(i);
    });
    observable2.subscribe(System.out::println);
    observable2.subscribe(System.out::println);

    System.out.println("//------------------- concatArrayDelayError ----------------------------");

    AtomicReference<String> ipAddress = new AtomicReference<>("");
    Map<String,String> map1 = new HashMap<>();
    map1.put("net-ip","333");map1.put("ip-address","132333");
    Map<String,String> map2 = new HashMap<>();
    map2.put("hostname","kekdkd");map2.put("ip-address","232233");map2.put("operating-system","win11");

    /*
    Single-thread
    By default, Rx is single-threaded which implies that an Observable and the chain of operators that we can apply to it will notify its observers on the same thread on which its subscribe() method is called
    */
    //concatArrayDelayError
    //Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate

    //concatArrayEagerDelayError
    //Concatenates an array of ObservableSources eagerly into a single stream of values and delaying any errors until all sources terminate
    Observable.concatArrayEagerDelayError(getIpFromMap1(map1), getIpFromMap2(map2))
    .subscribe(ipAddressVal -> ipAddress.set(ipAddressVal));
    System.out.println(ipAddress.get()); //232233

Java 10
=============

var
---------
method local variable type inference
var won’t work without the initializer and with null
var won't work with lambda and array as they need specific type

var list = new ArrayList<String>();  // infers ArrayList<String>

String[] strArr = {"a","b","c"};
var strArr = {"a","b","c"}; // Won't work

var expression = (String s) -> s.length() > 10;  // Won't work

Java 11
==============
String :: isBlank, lines, strip, stripLeading, stripTrailing, and repeat
-----------------------------------------------------------------------------------

//String :: isEmpty/isBlank
String strTest = " ";
System.out.println("isEmpty :: " + strTest.isEmpty()); //false
System.out.println("isBlank :: " + strTest.isBlank()); //true

//String :: lines : to get all words in a paragraph
strTest =  "Hi All. \nThis is a new line.\nThis is another line.\n Thank you.";
String words = strTest.lines().collect(Collectors.joining());
System.out.println("All words in paragraph are :: ");
System.out.println(words);

//String :: strip
strTest =  "   Hi   ";
ans = strTest.strip();
System.out.println("after strip :: " + ans);

//String :: repeat
String abc = "abc";
abc = abc.repeat(10);
System.out.println(abc);  //abcabcabcabcabcabcabcabcabcabc

Files :: readString, writeString
-----------------------------------------------------------------------------------
Path path = Paths.get("src/main/resources/abc.txt");

//Read file
String data = Files.readString(path);
System.out.println("File contents :: ");
System.out.println(data);

//Create file
path = Paths.get("src/main/resources/abc2.txt");
Files.deleteIfExists(path);
Files.createFile(path);

//Write to file
Files.writeString(path, "Sample text again", StandardOpenOption.APPEND);

Predicate.not
--------------------
//Remove all null and blanks and join the strings by ;
str = "abhik, rahul, joy, ,1,  ";
ans = Arrays.asList(str.split(",")).stream().map(String::trim).filter(Predicate.not(String::isBlank)).collect(Collectors.joining(";"));
System.out.println(ans); //abhik;rahul;joy;1

Java 12
=============

improved switch-case
--------------------------

//switch-case 1
inputStr = "test";
ans =  switch (inputStr.toUpperCase()) {
    case null -> throw new RuntimeException("null input");
    case "XYZ", "ABC" -> inputStr;
    case "TEST" -> "testing";
    default -> "abc";
};
System.out.println("switch-case 1 :: " + ans);  //testing

//switch-case 2
inputStr = "test";
switch (inputStr.toUpperCase()) {
    case null -> throw new RuntimeException("null input");
    case "XYZ", "ABC" -> ans = inputStr;
    case "TEST" -> ans = "testing";
    default -> ans = "none";
}
System.out.println("switch-case 2 :: " + ans);  //testing

//switch-case-when
final String inputStr2 = "yes";
switch(inputStr2){
    case null -> throw new RuntimeException("its null value");
    case String s when "Yes".equalsIgnoreCase(inputStr2) -> ans = "Yes its a yes";
    case String s when "No".equalsIgnoreCase(inputStr2) -> ans = "No its a no";
    case String s -> ans = inputStr2.toUpperCase(); //default
}
System.out.println("switch-case-when :: " + ans);  //Yes its a yes

Java 14
=============

record
--------------------------
Record is an immutable data transfer object
- Constructor
  Getters (without the “get” prefix)
  equals(), hashCode(), and toString() implementations

record NewPerson (@NotNull String name, @NotNull String address){
}

//Record ex
NewPerson newPerson = new NewPerson("John", "little avenue");
System.out.println(newPerson.name());
System.out.println(newPerson.address());

NewPerson newPerson2 = new NewPerson("John", "little avenue");
System.out.println(newPerson.name());
System.out.println(newPerson.address());
if(newPerson2 instanceof NewPerson(String name, String address)){
    System.out.println(name);
    System.out.println(address);
}

Java 15
==============

    String Text Blocks
--------------------------

String json = """
         {
          "name": "John",
          "address": "little avenue"
         }
        """;
ObjectMapper objectMapper = new ObjectMapper();
NewPerson2 np2 = objectMapper.readValue(json, NewPerson2.class);
System.out.println(np2.getName() + "--" + np2.getAddress());

inputStr = """
        This is the first line \n
        This is the second line \\r
        This is the third line
        This is the fourth line      \s
        This is the %s line
        """.formatted("fifth");
System.out.println(inputStr);
/*This is the first line

This is the second line \r
This is the third line
This is the fourth line------
This is the fifth line*/

.collect(Collectors.toList()) -> .toList()

Java 16
==============

pattern matching for instanceof
----------------------------------

if (person instanceof Employee e) {
   return e.getEmployeeId();
}

Vector API
--------------
  -for complex mathematical functions

Foreign functions and Memory API
----------------------------------
  -provides classes and methods to interact with native code

ZGC
-------------
Concurrent, low-latency GC 
-XX:+UseZGC.
ZGC outperform G1GC :: reduced garbage collection time, lower memory usage, lower response times, higher throughput


Java 17
=======================

Sealed Class and Interface
-------------------------------
-  restricts the subclasses that can implement an interface or extend a class

public sealed interface SealedEx permits ChildInt {

}
public non-sealed interface ChildInt extends SealedEx {
}

public class ChildIntImpl implements ChildInt{

}

Java 21
======================

1. Virtual Threads
==============================

Virtual Thread   ::        VT1-VT6    VT10-VT16   VT100-VT106  VT120-VT126  VT130-VT136
(on top of PT - do not block PT - For blocking operations, Virtual Threads can be suspended and resumed)
(When a VT needs to perform a blocking op it is unmounted from the PT and put in heap. When the blocking operation has completed it is taken from the heap and moved to a waiting list for the platform thread it was initially mounted on)

Platform Thread  ::         PT1         PT2         PT3          PT4           PT5
(1-1 mapping)
OS Thread        ::         OT1         OT2         OT3          OT4           OT5

Virtual Threads doesn’t improve latency but it is highly beneficial for requests with blocking IO operations

spring.threads.virtual.enabled=true
									      
Runnable r = () -> System.out.println("New virtual thread");
Thread.ofVirtual().start(r);
Thread.sleep(1000);

//executor service that creates a new Virtual Thread for each task submitted to it
try(ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()){
    Future<?> future = executorService.submit( () -> System.out.println("aaa"));
    future.get();
}catch (Exception e ){
    e.printStackTrace();
}

Thread virtualThread = Thread.startVirtualThread(() -> {
    System.out.println("Running task in a virtual thread: "
	    + Thread.currentThread().getName());
});
try {
    virtualThread.join();
} catch (InterruptedException e) {
    e.printStackTrace();
}


2. Record patterns
==============================
public record NewPerson(String name, String address) {}

//before Record pattern
NewPerson newPerson = new NewPerson("John", "little avenue");
System.out.println(newPerson.name());
System.out.println(newPerson.address());

//after Record pattern
NewPerson newPerson2 = new NewPerson("John", "little avenue");
if(newPerson2 instanceof NewPerson(String name, String address)){    //removes explicit casting
    System.out.println(name);
    System.out.println(address);
}

3. Pattern Matching with switch (switch + instanceof)
==============================================================

//switch-case 1
inputStr = "test";
ans =  switch (inputStr.toUpperCase()) {
    case null -> throw new RuntimeException("null input");
    case "XYZ", "ABC" -> inputStr;
    case "TEST" -> "testing";
    default -> "abc";
};
System.out.println("switch-case 1 :: " + ans);  //testing

//switch-case 2
inputStr = "test";
switch (inputStr.toUpperCase()) {
    case null -> throw new RuntimeException("null input");
    case "XYZ", "ABC" -> ans = inputStr;
    case "TEST" -> ans = "testing";
    default -> ans = "none";
}
System.out.println("switch-case 2 :: " + ans);  //testing

//switch-case-when
final String inputStr2 = "yes";
switch(inputStr2){
    case null -> throw new RuntimeException("its null value");
    case String s when "Yes".equalsIgnoreCase(inputStr2) -> ans = "Yes its a yes";
    case String s when "No".equalsIgnoreCase(inputStr2) -> ans = "No its a no";
    case String s -> ans = inputStr2.toUpperCase(); //default
}
System.out.println("switch-case-when :: " + ans);  //Yes its a yes

// Pattern Matching with switch (switch + instanceof)
Object object = new String("abc");
String someOutput =  switch (object) {
    case null -> throw new RuntimeException("its null value");
    case String s      -> s;
    case JSONPObject json -> json.toString();
    case BigDecimal bd   -> bd.toPlainString();
    case Integer i       -> Integer.toString(i);
    case LocalDate ld    -> ld.format(DateTimeFormatter.ISO_LOCAL_DATE);
    default              -> "n/a";
};
System.out.println("Pattern matching with switch :: " + someOutput); //abc

4. SequencedCollection
========================================
interface SequencedCollection<E> extends Collection<E> {

    // new method
    SequencedCollection<E> reversed();

    // methods promoted from Deque
    void addFirst(E);
    void addLast(E);

    E getFirst();
    E getLast();

    E removeFirst();
    E removeLast();
}

Sealed Interface implemented by Record
------------------------------------------------

public sealed interface Employee permits RegularEmp, Freelancer{

    String getName();
    String getDepartment();
}

public record RegularEmp(String name, String department, double salary) implements Employee{
    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getDepartment() {
        return department;
    }
}

public record Freelancer(String name, String department, double hourlyRate) implements Employee{
    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getDepartment() {
        return department;
    }
}

public class SealedInterfaceEx {

    public static void main(String[] args) {
        Employee regularEmp = new RegularEmp("Reg","ADM", 233.40);
        Employee freeLancer = new Freelancer("Reg","ADM", 12.40);
        processEmployee(regularEmp);
    }

    private static void processEmployee(Employee employee) {
        if(employee instanceof RegularEmp(String name, String department, double salary)){
            System.out.println("RegularEmp :: " + name + "," + department + "," + salary);
        } else if(employee instanceof Freelancer(String name, String department, double hourlyRate)){
            System.out.println("Freelancer :: " + name + "," + department + "," + hourlyRate);
            //RegularEmp :: Reg,ADM,233.4
        }
    }
}



SOLID Principles in Java
===============================

S — Single Responsibility Principle
O — Open-Closed Principle
L — Liskov Substitution Principle
I — Interface Segregation Principle
D — Dependency Inversion Principle

Single Responsibility Principle : every class should have Single responsibility

Open-Closed Principle : open for extension, closed for modification (abstract class)

    public abstract class DiscountCalculator {
        public abstract double calculateDiscount(Order order);
    }

    public class VIPDiscountCalculator extends DiscountCalculator {
        @Override
        public double calculateDiscount(Order order) {
            // VIP discount calculation logic
        }
    }

Liskov Substitution Principle : sub class object can substitute super class object

	class Animal {
	    public void makeSound() {
	        System.out.println("Some sound...");
	    }
	}
	
	class Cat extends Animal {
	    @Override
	    public void makeSound() {
	        System.out.println("Meow");
	    }
	}
	
	public class Main {
	    public static void main(String[] args) {
	        Animal myCat = new Cat();
	        myCat.makeSound(); // Output: Meow
	    }
	}

		Liskov Substitution Principle with wildcards
		-----------------------------------------------------------

		class Animal {
		    public void makeSound() {
		        System.out.println("Some sound...");
		    }
		}
		
		class Cat extends Animal {
		    @Override
		    public void makeSound() {
		        System.out.println("Meow");
		    }
		}
		
		class Dog extends Animal {
		    @Override
		    public void makeSound() {
		        System.out.println("Woof");
		    }
		}
		
		public class WildcardExample {
		    // Method using an unbounded wildcard
		    public static void printList(List<?> list) {
		        for (Object elem : list) {
		            System.out.println(elem);
		        }
		    }
		
		    // Method using an upper bounded wildcard
		    public static void makeAnimalsSound(List<? extends Animal> animals) {
		        for (Animal animal : animals) {
		            animal.makeSound();
		        }
		    }
		
		    // Method using a lower bounded wildcard
		    public static void addCat(List<? super Cat> cats) {
		        cats.add(new Cat());
		    }
		
		    public static void main(String[] args) {
		        List<Cat> cats = new ArrayList<>();
		        cats.add(new Cat());
		        
		        List<Dog> dogs = new ArrayList<>();
		        dogs.add(new Dog());
		
		        // Unbounded wildcard example
		        printList(cats);
		        printList(dogs);
		
		        // Upper bounded wildcard example
		        makeAnimalsSound(cats);
		        makeAnimalsSound(dogs);
		
		        // Lower bounded wildcard example
		        List<Animal> animals = new ArrayList<>();
		        addCat(animals);
		        makeAnimalsSound(animals); // Output includes "Meow"
		    }
		}

Interface Segregation Principle : segregate interfaces into smaller interfaces - Interfaces should be tailored to the needs of the classes that implement them 


Dependency Inversion Principle :  Interface abstraction layer between high-level and low-level modules


//get all employees from all departments in a Company using Dependency Inversion Principle
interface Company {
    List<DEmployee> getAllEmployees();
}

interface CDepartment {
    List<DEmployee> getEmployees();
}

@AllArgsConstructor
@Data
class DEmployee {
    private int employeeId;
    private String employeeName;
}

class Admin implements CDepartment {
    @Override
    public List<DEmployee> getEmployees() {
        return List.of(new DEmployee(1, "Aaa"), new DEmployee(2, "Bbb"));
    }
}

class IT implements CDepartment {
    @Override
    public List<DEmployee> getEmployees() {
        return List.of(new DEmployee(3, "Ccc"), new DEmployee(4, "Ddd"));
    }
}

class IBM implements Company{

    private List<CDepartment> departmentList;

    public IBM(List<CDepartment> departmentList){
        this.departmentList = departmentList;
    }

    private List<DEmployee> employees = new ArrayList<>();

    @Override
    public List<DEmployee> getAllEmployees() {
        for(CDepartment cDepartment : departmentList){
            employees.addAll(cDepartment.getEmployees());
        }
        return employees;
    }
}

public class DependencyInversionPEx {
    public static void main(String[] args) {
        List<DEmployee> employees = new ArrayList<>();

        CDepartment admin = new Admin();
        employees.addAll(admin.getEmployees());
        CDepartment it = new IT();
        employees.addAll(it.getEmployees());

        Company ibm = new IBM(List.of(admin, it));
        ibm.getAllEmployees().forEach(System.out::println);
    }
}

//---------------------------------- Optional ------------------------------------//

Optional.of         : when the value is non-nullable
Optional.ofNullable : when the value is nullable
orElse() 	    : always call
orElseGet()	    : when the value is not present


 // --------------------------- Remove if-else-if ----------------------------------//

        String aa = "abc";

        if(check1(aa)!=null){
            doAction(check1(aa));
        } else if (check2(aa)!=null) {
            doAction(check2(aa));
        } else if (check3(aa) != null) {
            doAction(check3(aa));
        }

        Optional.ofNullable(check1(aa))
                .or(() -> Optional.ofNullable(check2(aa)))
                .or(() -> Optional.of(check3(aa)))
                .ifPresent(checkResult -> doAction(checkResult));


  // --------------------------- Agile ----------------------------------//

 Agile Manifesto
 -----------------------

  1. Individuals and Interactions OVER processes and tools
  2. Working software OVER comprehensive documentation
  3. Customer collaboration OVER contract negotiation
  4. Responding to change OVER following a plan

 Agile Methodology
 --------------------
   1. Continuous Iteration
   2. Continuous Improvement
   3. Continuous Interaction
   4. Fast release
   5. Regular stand-ups
   6. Proper tools

Continuous Integration, Continuous Delivery, Continuous Deployment
----------------------------------------------------------------------

Continuous Integration : Developers merge their change to release branch as much as possible. Each check-in is then verified by an Automated build, allowing teams to detect problems early.
Continuous Delivery : Automated Testing + Automated Release
Continuous Deployment : Every change that passes all stages of the production pipeline is deployed at the customer end.


Domain Driven Design
--------------------------------
A design approach where the business domain is mapped to technical objects and evolved over time.

Agile Framework
------------------
Scrum
    Product Vision
    Product Backlog
    Burndown Charts
    Regular Stand-Ups

Kanban
    Kanban board (‘to-do’, 'in-progress','on-hold','in-review','in-acceptance','done')
    Regular Stand-Ups
    Continuous Feedback
    Product Backlog
    Product Vision


Lean Development Model
------------------------------
Identifying Value
Reducing Waste
Continuous Improvement

DevOps
----------------
DevOps is a software development model which focuses on constant collaboration
 among Development and Operations Team which allows deploying code to production faster and in an automated way.


Agile  vs DevOps
------------------------

Customer                    Developer                   IT Ops
        ------------->                  ------------>
         Agile                           DevOps

        . Continuous Iteration          Constant collaboration among Dev and Ops to promote code faster to Production in a automated way
          Continuous Improvement        Constant testing and delivery
          Continuous Feedback
          Small rapid release
          Regular stand-ups
          Usage of proper tools

          Target :: Software Delivery   Target :: End-to-end business solutions
          Functional readiness          Operational readiness


Simplicity Criteria
------------------------
no duplicate code
passes automated tests
expresses each idea separately
minimum number of components

Test Driven Development
---------------------------------

write a “single” unit test describing an aspect of the program
run the test, which should fail because the program lacks that feature
write “just enough” code, the simplest possible, to make the test pass
“refactor” the code until it conforms to the simplicity criteria
repeat, “accumulating” unit tests over time

Behaviour Driven Development
--------------------------------
refinement to TDD
implement only those behaviors which contribute most directly to these business outcomes, so as to minimize waste

Product Owner                                       vs                  Scrum Master
---------------------------------------------------------------------------------------------------
Prioritizing Product stories                                    Agile methodology is followed
Collaboration with the Development team                         Clears obstacles
Business knowledge of the product                               Communication between team and the PO


// -------------------------- Inner class --------------------------- //

Inner Class							                                Nested Class
----------------------------------------------------------------------------------------

non-static				                                            -static
can access ALL outer class members                                  -can access only static members of the Outer class members
OuterClass.InnerClass inner = new OuterClass().new InnerClass();    -OuterClass.InnerClass inner = new  OuterClass.InnerClass();

Inner class is created when the outer class ony references the inner class and code is kept at one place.
Anonymous inner class is an inner class without a name and for which only a single object is created. It is used when override a method of a class or interface.


public class InnerEx {

    static class InnerStatic {
        private class Private {
            private static int j = 20;
            private int i = 10;

            private String evenOdd(int num) {
                i = i+ j;
                return ((num % 2 == 0) ? "even" : "odd");
            }
        }
    }


    public static void main(String[] args) {

        //static Inner class
        InnerEx.InnerStatic.Private sip = new InnerEx.InnerStatic().new Private();
        String ans = sip.evenOdd(5);
        System.out.println("evenOdd :: " + ans + ":: i="+sip.i +" ::j="+ InnerStatic.Private.j);
        //evenOdd :: odd:: i=30 ::j=20*/

        //Anonymous Inner class

        class ABCD {
            public void print() {
                System.out.println("ABCD 1...");
            }
        }

        ABCD abcd = new ABCD() {
            @Override
            public void print() {
                System.out.println("ABCD 2...");
            }
        };
        abcd.print(); //ABCD 2...
    }


}

// -------------------------- Coding Checklist--------------------------- //

1. Does the code solve the problem 
2. Can the code be bettered  - more performance, security, maintainability, readability, reusability
3. Is any library used that was not needed OR an library thatcould have been used
4. SOLID principles

JVM Memory Management
--------------------------------------------------------------------
JVM Memory = Heap memory + Stack memory + Metaspace

Heap memory - Objects, Arrays, String Pool

	         -Xms: Initial Heap Size (e.g., -Xms512m)
             -Xmx: Maximum Heap Size (e.g., -Xmx2g) (default 64 Mb)

            YOUNGGen                            OLDGen

            (Eden SO S1)
        Referred objects in Eden are put into S0, unreferred objects are cleared out
        This pattern continues until the eden space becomes full once more
        All the marked objects that survive both the eden space and S0 are moved to S1

                  Any object that have survived a certain number of cycles in the survivor space are moved by the algorithm to the OLD Gen
                  Generational Garbage Collection on the OLD gen

Stack memory  - local variables

            1. LIFO structure
            2. Every thread has its own stack

Metaspace - Metadata, Classes, static data

            1. Can grow dynamically as against PermGen ( so no OutOfMemoryError)

------------------------------------------------------------------------------------------------------

Memory Leaks
===========================
Situation where there are objects in the Heap that are no longer used, but cannot be GCed
	- can result in java.lang.OutOfMemoryError.

The garbage collector removes unreferenced objects periodically, but it never collects the objects that are still being referenced.
This is where memory leaks occur

Causes : 

   1. Islands of Isolation
	- removed by Mark and Sweep Algorithm

   2. Unclosed resources
	- try-with-resources

   3. Static variables can cause memory leaks
      (As Static data lives throughout the life cycle of the class,they can hold references to objects that are no longer accessed)

   4. Full-load
	- Streaming

Tracking : 

1. JConsole -  inspect the stack trace of each thread
2. JProfiler - monitor memory allocation and garbage collection in real-time


--------------------------------------------------------------------------------------------------

Garbage Collection
===================================
Garbage Collection is freeing up memory by deleting objects that do not have a live reference. (live reference =  objects can be reached from the application through a chain of references )

Mark and Sweep Algorithm
-----------------------------
When a object is created its mark-bit=0
Phase 1 - Mark : all live objects::  mark-bit = 1
Phase 2 - Sweep : all objects with mark-bit=0 are removed and live objects reset to mark-bit=0

Garbage Collection Types
-----------------------------
1. Serial Garbage Collector -  runs on a single thread
2. Parallel Garbage Collector - runs on multiple threads, but freezes the application
3. G1 Garbage Collector - divides the Heap area into equal-sized regions
                         Mark and Sweep from the area that has most garbage
                         java -XX:+UseG1GC -jar Application.java
                         default
4. Z Garbage Collector - divides the Heap area into Unequal-sized regions,
                        ZGC performs all expensive work concurrently, without stopping the application for more than 10 ms
                        java -XX:+UseZGC -jar Application.java
   	                    ZGC outperform G1GC :: reduced garbage collection time, reduced latency, more throughput


--------------------------------------------------------------------------------


Functional Interface
------------------------------
Interface with only 1 abstract method (can have default,static, overridden methods)

1. Supplier
@FunctionalInterface
public interface Supplier <R> {
    R get();
}
int a = list.stream().findAny().orElseGet(()->40);

2. Consumer
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
//Consumer<Integer> display = a -> System.out.println(a);
//display.accept(10);

3. Function
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
Function<Integer, Integer> functionA = x -> x.intValue()*10;
int y = functionA.apply(10);

4. Predicate
@FunctionalInterface
public interface Predicate <T> {
    boolean test(T t);
}
List<Integer> list = list.stream().filter(a ->a%2==0).tolist();

5. Runnable
@FunctionalInterface
public interface Runnable {
    void run();
}
Runnable r1 = () -> {  
         System.out.println("Runnable with Lambda Expression");
      };
new Thread(r1).start();
    

6. Callable
@FunctionalInterface
public interface Callable <V> {
    V call() throws java.lang.Exception;
}
testInt(() -> {
    System.out.println("From testInt method");
    return 1;
});

testVoid(() -> {
    System.out.println("From testVoid method");
    return null;
});

public static void testInt(Callable<Integer> callable) throws Exception {
	callable.call();
}

public static void testVoid(Callable<Void> callable) throws Exception {
	callable.call();
}


FunctionalInterface
-----------------------------------------------------------
1 abstract method (can have default,static, overridden methods)

Lambda
------------------------------------------------------------
Lambda is an anonymous function that implements FunctionalInterface

first-class function
-----------------------------------
	1. Function can be assigned to a variable 
	2. Function can be passed to another function 
	3. Function can be returned from another function

Lambda is a first-class function



@FunctionalInterface
interface MathsOperation {
	int mathsOp(int a, int b);
}

public class LambdaEx {

	public static void main(String[] args) {

		//Lambda is an anonymous function that implements FunctionalInterface

		//assign Lambda to a variable
		MathsOperation addition = (a, b) -> a + b;  //(a, b) -> a + b; :: Lambda 
		System.out.println(addition.mathsOp(10, 5)); // 15

		//Lambda variables are final - to reduce concurrency issues
		List<String> list = Stream.of("abc", "def", "mno", "xyz").toList();
		AtomicInteger i = new AtomicInteger(0);
		list.forEach(s -> {
			System.out.print(i + ":" + s + ":"); //0-abc:1-def:2-mno:3-xyz:
			i.getAndIncrement();
		});
		System.out.println();

		/*int[] arr = new int[]{0};
		list.forEach(elm -> {
			System.out.print(arr[0] + ":" + elm + ":"); //0:abc:1:def:2:mno:3:xyz:
			arr[0]++;
		});*/

		//passing lambda to a function (which will accept FunctionalInterface)
		Function<Integer, Integer> function1 = x -> x *10;
		int j1 = testF(10, function1);
		System.out.println("function1 ::" + j1);  //100
		Function<Integer, Integer> function2 = x -> x+10;
		int j2 = testF(10, function2);
		System.out.println("function2 ::" + j2); //20
		Function<Integer, Integer> function3 = x -> x+100;
		int j3 = testF(10, function3);
		System.out.println("function 3 :: " + j3); //110

		//return lambda
		int lambdaOp = getAddition().mathsOp(20, 30);
		System.out.println("lambdaOp :: " + lambdaOp); //320

		//Function
		Function<Integer, Integer> functionA = x -> x *10;
		int y = functionA.apply(10);
		System.out.println("function :: " + y); //100

	    //BiFunction :: Functional interface with 2 inputs
        /*
            @FunctionalInterface
            public interface BiFunction<T, U, R> {
                R apply(T t, U u);
            }
        */
        BiFunction<Integer, Integer, Integer> biFunction = (x1, x2) -> x1 + x2;
        Integer resultBF = biFunction.apply(2, 3);
        System.out.println("resultBF :: " + resultBF); // 5

        //Map to replace multiple if, else-if
        Map<String, BiFunction<Integer, Integer, Integer>> map = new HashMap<>();
        map.put("add", (x1, y1) -> x1+y1+10);
        map.put("subtract", (x1, y1) -> x1-y1+10);
        map.put("multiply", (x1, y1) -> x1*y1+10);
        map.put("divide", (x1, y1) -> x1/y1+10);

        Integer mathOpResult = map.get("add").apply(2, 3);
        System.out.println("mathOpResult :: " + mathOpResult);

		//BinaryOperator
		/*
			@FunctionalInterface
			public interface BinaryOperator<T> extends BiFunction<T,T,T> {

			}
		 */
		//Functional interface that extends BiFunction
		//same-type
		BinaryOperator<Integer> binaryOperator = (x1, x2) -> x1 + x2;
		Integer resultBO = binaryOperator.apply(2, 3);
		System.out.println("resultBO :: " + resultBO); // 5

		//Higher-Order Function
		//Function as input and/or Function as output
		IntBinaryOperator add = (a, b) -> a + b;
		IntBinaryOperator subtract = (a, b) -> a - b;
		IntBinaryOperator multiply = (a, b) -> a * b;

		int x1 = 10;
		int y1 = 5;
		int resultAdd = applyOperation(x1, y1, add);
		int resultSubtract = applyOperation(x1, y1, subtract);
		int resultMultiply = applyOperation(x1, y1, multiply);
		System.out.println("Addition: " + resultAdd); // Output: Addition: 15
		System.out.println("Subtraction: " + resultSubtract); // Output: Subtraction: 5
		System.out.println("Multiplication: " + resultMultiply); // Output: Multiplication: 50

		//Composite Function
		//Function chaining - output of 1 function is input of the next function
		//Function.andThen
		Function<Integer, Integer> addTwo = xy -> xy+2;
		Function<Integer, Integer> multiplyByThree = xy -> xy*3;
		Function<Integer, Integer> compositeFunction = addTwo.andThen(multiplyByThree);
		Integer resultComposite = compositeFunction.apply(5);
		System.out.println("resultComposite :: " + resultComposite); //21

		//Lambda and exceptions
		//If a lambda throws a Exception, then the Functional Interface method must throw the same exception or supertype


	}


	public static MathsOperation getAddition(){
		return (a,b) -> a+10*b;
	}

	// Higher-Order Function
	 public static Integer testF(Integer x, Function<Integer, Integer> function){
		return function.apply(x);
	 }

	// Higher-Order Function
	public static int applyOperation(int a, int b, IntBinaryOperator operation) {
		return operation.applyAsInt(a, b);
	}

	//BiFunction
	private static <T,U, R> List<R> listCombiner(List<T> list1, List<U> list2, BiFunction<T,U,R> biFunction){
		List<R> resultList = new ArrayList<>();
		for(int i=0;i<list1.size();i++){
			resultList.add(biFunction.apply(list1.get(i), list2.get(i)));
		}
		return resultList;
	}

}

Intermediate             vs                     			Terminal           operations in Stream
--------------------------------------------------------------------------------------------
-returns Stream								-returns Integer/List/Boolean

map()								        count()
flatMap()							        collect()
filter()						    		reduce()
sorted()						        	findFirst() / findAny()
distinct()						        	allMatch() / anymatch()
limit()
peek() [for debugging]

   Stateless        Stateful
    map()           sorted()
    filter()        distinct()

Encapsulation                           vs                      Abstraction
----------------------------------------------------------------------------------------
Containing the data and the accessors to the data in a single class thereby
                hiding the internal state of the object from the outside world
private variables, getter/setter
Implementation level

                                                             Hiding unnecessary details from the user and showing only the necessary ones
                                                             Interface, abstract class
                                                             Design level


Async Call
---------------------------------

public static void main(String[] args) throws ExecutionException, InterruptedException {

        List<String> inputList = List.of("aaa", "bbb", "ccc");
        String outputList = String.join(",", inputList.stream().map(String::toUpperCase).toList());
        System.out.println(outputList);

        String outputList2 = "";
        List<CompletableFuture<String>> completableFutureList = inputList.stream().map(CompletableFutureEx::convertToUpper).toList();
        //wait for all CFs to complete
        CompletableFuture.allOf(completableFutureList.toArray(new CompletableFuture[0])).join();
        //get each CF
        for(CompletableFuture<String> cf: completableFutureList){
            if(cf.isDone()){
                outputList2 +=cf.get();
            }
        }
        System.out.println(outputList2);

}
private static CompletableFuture<String> convertToUpper(String inputString) {
    String output = inputString.toUpperCase();
    return CompletableFuture.completedFuture(output);
}



public CompletableFuture<FinalResultMovie> getFinalResultMovieASync(String heroName) throws ExecutionException {

        CompletableFuture<ResultHero> completableFuture1 = CompletableFuture.supplyAsync(()->{
            ResultHero resultHero = new ResultHero();
            resultHero.setAssistant1(Optional.ofNullable(heroesRepository.findByHeroNameIgnoreCase(heroName)).map(Heroes::getAssistant1).orElse("NA"));
            return resultHero;
        });
        CompletableFuture<ResultMovie> completableFuture2 = CompletableFuture.supplyAsync(()->{
            ResultMovie resultMovie = new ResultMovie();
            resultMovie.setMovies(movieRepository.findByHero(heroName));
            return resultMovie;
        });

        return CompletableFuture.allOf(completableFuture1, completableFuture2)
                .thenApplyAsync(value -> {

                    FinalResultMovie finalResultMovie = new FinalResultMovie();
                    finalResultMovie.setHeroName(heroName);

                    ResultHero resultHero = completableFuture1.join();
                    if(Objects.nonNull(resultHero)){
                        finalResultMovie.setAssistant1(resultHero.getAssistant1());
                    }

                    ResultMovie resultMovie = completableFuture2.join();
                    if(Objects.nonNull(resultMovie)){
                        finalResultMovie.setMovies(resultMovie.getMovies());
                    }

                    return  finalResultMovie;

                });

    }


HashMap                           vs                      HashTable
----------------------------------------------------------------------------------------
1.5                                                        Legacy
Non-synchronized                                           Synchronized
Fail-fast                                                  Fail-safe
Faster                                                     Slower
Null key / Null value                                      No null key /value


Fail-fast                        vs                         Fail-safe
-----------------------------------------------------------------------------
ConcurrentModificationException                             Slower
                                                            More memory
HashMap, ArrayList, HashSet                                 HashTable, ConcurrentHashMap, CopyOnWriteArrayList


Java Collection Framework
-------------------------------------

- API to do operations on Collections
- get(), add(), put(), remove(), size(), iterator(), clear()

                 Iterable

                 Collection                 Map

             Set    List   Queue

Interface           Class               Ordered             Sorted              Synchronized
-----------------------------------------------------------------------------------------------
Map               HashMap
                  HashTable                                                         yes
                  LinkedHashMap         yes
                  TreeMap                                   yes
                  ConcurrentHashMap                                                 yes

Set               HashSet
                  LinkedHashSet         yes
                  TreeSet                                   yes

List              ArrayList
                  Vector                                                            yes
                  LinkedList            yes
                  Stack
                  CopyOnWriteArrayList

Queue             PriorityQueue                             yes


How HashMap works
-----------------------
- buckets
- hashCode
- equals

map.put(key, value)
Bucket b = hashCode(key)
  Bucket		Entry<K,V>
	---------		------------------
	b1			Key1/Value1	Key2/Value2  (LinkedList)
	b2			Key3/Value3	Key4/Value4

map.get(key)
Bucket b =  hashCode(key)
In Bucket b, for each entry
if (key.equals(key1)) {
return value1
}else{
	go to next entry in bucket
}

Attributes of HashMap key
- Immutable
- Override hashCode() and equals()

Eg: String and Wrapper class


ArrayList				vs					LinkedList
--------------------------------------------------------------------------------------------------------	

1. Stores data in array							1. Stores data in doubly-linked nodes.
2. implements RandomAccess Interface					2. 
3. Search is fast							3. Search is slow
4. Insert/Delete is slow						4. Insert/Delete is fast
5. Lesser memory							5. More memory 


-------------------------------------------------------------------------

Exception Hierarchy
================================

                            THROWABLE

        ERROR                                       EXCEPTIOON

        OutOfMemoryError               RUNTIME EXCEPTION                    CHECKED EXCEPTION
        NoClassDefFoundError           NullPointerException                 IOException
                                       ClassCastException                       -FileNotFoundException
                                       ArithmeticException                      -EOFException
                                       NumberFormatException                ClassNotFoundException
                                       IllegalArgumentException             SQLException
                                       ArrayIndexOutOfBoundsException       InterruptedException
        
      (Environment error)               (Programming Error)                  (External condition check in code)
-------------------------------------------------------------------------

NoClassDefFoundError            vs                           ClassNotFoundException
=========================================================================================
Referenced class is not found at runtime in classpath      Class is not found at runtime in classpath

-------------------------------------------------------------------------

Diamond problem in java
============================
If a class implements 2 interfaces with same method signature then it must override the method 

interface InterfaceA {
    default void display() {
        System.out.println("Inside InterfaceA");
    }
}

interface InterfaceB {
    default void display() {
        System.out.println("Inside InterfaceB");
    }
}

class MyClass implements InterfaceA, InterfaceB {
    // Here, we must provide our own implementation of display to resolve the ambiguity.
    @Override
    public void display() {
        InterfaceA.super.display(); // calling InterfaceA's default implementation
        InterfaceB.super.display(); // calling InterfaceB's default implementation
    }
}


Immutable class
----------------------

// 1. final class - so cannot be extended
// 2. private final fields
// 3. no setters, only getters

public final class MyImmutable {

	private final int i;
	private final List<String> hobbies;

	//getters only
	public int getI() {
	   return i;
	}

	public List<String> getHobbies() {
     return new ArrayList<>(hobbies); // Return a new copy
    }
	
	public MyImmutable(int i, List<String> hobbies){
		this.i = i;
		this.hobbies = new ArrayList<>(hobbies);
	}
	
}

Advantages:
1. Security / Thread safety
2. Map key
3. Caching


Immutable Objects in Java
1. String
2. Wrapper classes


OverLoading 				vs  				OverRiding
==========================================================================================

1.  Same name								Same name

2.  Same class								subclass

3.  Argument list MUST CHANGE						Argument list EXACTLY MATCH / = erasure of superclass method signature

4.  Return type CAN CHANGE						Return type must be same / subclass

5.  									Cannot throw new or broader checked exceptions

6. 									Access level : same / broader

7. Compile-time	Polymorphism						Runtime Polymorphism


Overloading  ---> Widening – Boxing – Var Args
None of the wrapper classes widen from one to another.
widening/lessening and Boxing is not allowed

Comparator Interface vs Comparable Interface
----------------------------------------------
  
 Comparator						Comparable
-------------					       --------------
java.util						java.lang
public int compare(User u1, User u2){			public int compareTo(User u){
   int x = u1name.compareTo(u2name);				return this.getId() - u.getId();
}							}
 balls = balls.stream().sorted(Comparator.comparing(Ball::getColour)).toList()


Wrapper Classes 
-----------------------------------

1. Object representation of primitive data type.

2. 9 Wrapper classes 

3. Pkg : java.lang ; public, final


byte - > short -> int -> long -> float-> double
		   ^	
		   |
	          char		


boolean	  java.lang.Boolean
byte	  java.lang.Byte
short	  java.lang.Short
int	  java.lang.Integer
char	  java.lang.Character
long	  java.lang.Long
float	  java.lang.Float
double	  java.lang.Double
void 	  java.lang.Void	


3.

Primitive type			Wrapper class			Constructor Arguments
-------------------		---------------			------------------------

byte				Byte				byte or String
short				Short				short or String
int				Integer				int or String
long				Long				long or String
float				Float				float, double or String
double				Double				double or String
char				Character			char
boolean				Boolean				boolean or String


4.

Advantages 

	1. Wrapper class can be returned/passed in methods as Objects
	
	2. Wrapper class can be used in collections
	
	3. Wrapper classes have overridden equals method.	

	4. Utility Methods
	
		valueOf()     ---  to Wrapper
			Integer i1 = Integer.valueOf("3");
			Integer i2 = Integer.valueOf(123);
			Float f =    Float.valueOf("2.2");
				
		parseXXX()    --- String to primitive
					
			int i = Integer.parseInt("345");
			double d = Double.parseDouble("123.456");
			byte b = Byte.parseByte("127");	


Class and Interface design patterns
========================================
Single Responsibility
Open for extension, Closed for modification
Input Validation
Logging
Circuit breaker
Rate limiting
Concurrency
Data masking
Retry
Async
Caching

Java Integer Cache
=======================
-128 to 127 numbers are cached
new - always creates a object
Integer.valueOf - checks whethere the integer is in caching range - if yes then doesnt create new object

Integer a = new Integer("127");
Integer b = new Integer("127");
System.out.println(a == b);  // false

Integer c = Integer.valueOf("127");
Integer d = Integer.valueOf("127");
System.out.println(c == d);  // true

Integer e = Integer.valueOf("128");
Integer f = Integer.valueOf("128");
System.out.println(e == f);  // false

Integer a = 128;
Integer b = 128;
System.out.println(a == b); // false

Integer x = 1;
Integer y = 1;
System.out.println(x == y); // true

Context switching
=========================
Switching of CPU from 1 thread/process to another
State of the thread/process is saved for resume

Thread states
===================

	NEW	new()
	|	start()
	RUNNABLE
	|	JVM		sleep()/wait()/join()/ IO
	RUNNING		----------------------------------->  BLOCKED
	|
	TERMINATED

wait() : releases lock

t.join() - t will complete then main thread will continue
t.wait() - t releases lock, waits to get it back by notify()/notifyAll()
t.sleep() - t doesn't release lock
Thread.yield() - static method that hints to the thread scheduler that the current thread is willing to pause execution
                and allow threads with the same priority to execute, though it does not guarantee a pause.

wait() 
wait(long ms) 
wait(long ms, int nanos) 
1.IllegalMonitorStateException - not in a synchronized block
2.IllegalArgumentException - if the timeout value passed is invalid 
3.InterruptedException - if another thread interrupts the current thread. 



Thread Scheduler
========================
determines which thread will run next which are in RUNNABLE state depending on their priority
	- Preemptive Scheduling : When a high-priority process comes in the ready queue, it doesn't have to wait for the running process to finish its burst time.
	      However, the running process is interrupted in the middle of its execution and placed in the ready queue until the high-priority process uses the resources.
	- Time Slicing          : CPU time will be sliced among the threads, each thread will get fixed time and in round-robin fashion
	

finalize
==================
protected void finalize() throws Throwable
{
try {

    System.out.println("inside demo's finalize()");
}
catch (Throwable e) {

    throw e;
}
finally {

    System.out.println("Calling finalize method"
		       + " of the Object class");

    // Calling finalize() of Object class
    super.finalize();
}
//If an uncaught exception is thrown during the finalization, the exception is ignored and finalization of that object stops
}

Class.forName()
====================
Dynamically load a class at runtime by its name
Commonly used to create database connections to load the JDBC driver class.

Parallel Stream
==================
Utlizes multicore processors by dividing the workload among multiple threads
- improves performance and reduces latency

Path pathFile = Paths.get("src/main/resources/abc.log");
BigDecimal amountSumGTLakh = Files.lines(pathFile)
                            .parallel() //changing to parallel stream
                            .map(FileEx::getAmountFromLog)
                            .reduce(BigDecimal.ZERO, BigDecimal::add);
System.out.println("amountSumGTLakh :: " + amountSumGTLakh); //280000

----------------------------------------------------------------------------------

Build Thread-Safe Applications
-------------------------------------------------------------------

Key Principles of Thread Safety :
    Atomicity: Operations must be atomic(single step)
    Visibility: Changes made by one thread should be visible to others.
    Order: Operations must execute in the correct sequence.

Common Problems in Multi-threading :
    Race Conditions: 2/more threads competing to update the same resource
    Deadlocks: 2/more threads block each other by holding resources that the others need
    Livelocks: Threads keep changing their states in response to each other but do no productive work.
    Starvation: A thread is perpetually denied access to resources.

1. Critical section locking
-----------------------------------

public synchronized void transfer(Account from, Account to, int amount) {
    from.withdraw(amount);
    to.deposit(amount);
}

public void transfer(Account from, Account to, int amount) {
    synchronized (from) {
        from.withdraw(amount);
    }
    synchronized (to) {
        to.deposit(amount);
    }
}

2. ReentrantReadWriteLock
------------------------------------
for High-Read, Low-Write Scenarios

public class ReentrantReadWriteLockExample {

    private static final ReentrantReadWriteLock reEntrantRWLock = new ReentrantReadWriteLock(true);

     public static void main(String[] args) {
            reEntrantRWLock.writeLock().lock(); // no other threads can enter
            message = message.concat("a");
            reEntrantRWLock.writeLock().unlock();

            reEntrantRWLock.readLock().lock();
            System.out.println("Message is " + message);  //other threads can get readLock provided they dont have writeLock
            reEntrantRWLock.readLock().unlock();

     }

}

3. Avoid Race Condition (2/more threads competing to acquire the same resource)
-----------------------------------------------------------------------

//Semaphore


@AllArgsConstructor
@Getter
@Setter
class JointAccount extends Thread {
    public static int BALANCE = 100;
    private Semaphore semaphore;
    private String threadName;

    public void increment(Integer sum) {
        BALANCE = BALANCE + sum;
    }


    @SneakyThrows
    @Override
    public void run() {
        semaphore.acquire();
        System.out.println("Thread :: " + threadName + " gets object lock");
        if (threadName.equals("tA")) {
            increment(2000);
        } else if (threadName.equals("tB"))
            increment(1000);
        System.out.println("Thread :: " + threadName + " releases object lock");
        semaphore.release();

    }

}

public class RaceConditionEx {


    public static void main(String[] args) throws InterruptedException {

        Semaphore semaphore = new Semaphore(1);

        JointAccount jointAccountA = new JointAccount(semaphore, "tA");
        JointAccount jointAccountB = new JointAccount(semaphore, "tB");

          // If any ordering of jointAccountA, jointAccountB to run b ut whichever runs wil complete and then the other will run

         jointAccountA.start();
         jointAccountB.start();

          System.out.println("Balance :: " + BALANCE);

        // If jointAccountA to run before jointAccountB

        jointAccountA.start();
        jointAccountA.join();

        jointAccountB.start();
        jointAccountB.join();

         System.out.println("Balance :: " + BALANCE);

      

        /*
                Thread :: tA gets object lock
                Thread :: tA releases object lock
                Thread :: tB gets object lock
                Thread :: tB releases object lock
                Balance :: 3100

         */
    }
}

4. Avoid Deadlock (2/more threads block each other by holding resources that the others need)
--------------------------------------------------------------------------------------

//synchronized + JOIN

public class DeadlockEx {

	public static void main(String[] args) throws InterruptedException {

		String resource1 = "resource1";
		String resource2 = "resource2";

		Thread t1 = new Thread() {
			@Override
			public void run() {
				synchronized (resource1) {
					System.out.println(Thread.currentThread().getName() + resource1);
				}
				try {
					Thread.sleep(100);
				} catch (Exception e) {
				}
				synchronized (resource2) {
					System.out.println(Thread.currentThread().getName() + resource2);
				}

			}
		};

		Thread t2 = new Thread() {
			@Override
			public void run() {
				synchronized (resource2) {
					System.out.println(Thread.currentThread().getName() + resource2);
				}

				try {
					Thread.sleep(100);
				} catch (Exception e) {
				}
				synchronized (resource1) {
					System.out.println(Thread.currentThread().getName() + resource1);
				}
			}

		};

		t1.start();
		t1.join(); //Solution to deadlock :: t1 to complete before main thread can run

		t2.start();
	}

	/*
		Thread-0resource1
		Thread-0resource2
		Thread-1resource2
		Thread-1resource1
	 */

}

5. Atomic variables (lock-free)
------------------------------------

//AtomicInteger replaces synchronized

AtomicInteger count = new AtomicInteger(0);
for (int i = 0; i < 1000; i++) {
   count.getAndIncrement();
}
System.out.println("Final count (with AtomicInteger): " + count.get());

List<String> list = Stream.of("abc", "def", "mno", "xyz").toList();
AtomicInteger i = new AtomicInteger(0);
list.forEach(s -> {
    System.out.print(i + ":" + s + ":"); //0-abc:1-def:2-mno:3-xyz:
    i.getAndIncrement();
});

AtomicInteger
AtomicBoolean
AtomicLong
AtomicReference<String>
AtomicReference<Double> atomicReference = new AtomicReference<>((double)0);
    - BinaryOperator<Double> binaryOperator = (u,v) -> u+v;
      atomicReference.accumulateAndGet(costOfItem, binaryOperator);
AtomicReference<BigDecimal> highestSavingsAmount = new AtomicReference<>(BigDecimal.ZERO);
    - loop -> {
         highestSavingsAmount.getAndAccumulate(bigDecimal, BigDecimal::add);
      }


6. ThreadLocal (variables which are local to a thread, child class cannot access)
------------------------------------------------------------------------------------

public static final ThreadLocal<Book> threadLocalBook = new ThreadLocal<>();

threadLocalBook.set(new Book("My First Book", "First Author", 1984, "0395489318", 230));
Book book = threadLocalBook.get();


----------------------------------------------------------------------------------

ReentrantLock
--------------------

/*
    ReentrantLock allows a thread to acquire an object lock multiple times
    Fair locking - new ReentrantLock(true);	// the thread that has waited the maximum time for the object lock gets the lock
    reentrantLock.lock()
    reentrantLock.tryLock(10,TimeUnit.SECONDS)
    reentrantLock.lockInterruptibly()   //current thread is waiting for lock but some other thread requests the lock, then the current thread will be interrupted and return                                        immediately
    reentrantLock.unlock()

    synchronized                        vs                              ReentrantLock
    --------------------------------------------------------------------------------------
    unstructured - do not need a block structure
    lock can be held across methods
 */

public class ThreadRunByReentrantLock implements Runnable{

    ReentrantLock reentrantLock = new ReentrantLock(true);

    public static void main(String[] args) throws InterruptedException {

        ThreadRunByReentrantLock client = new ThreadRunByReentrantLock();

        Thread thread1 = new Thread(client, "thread1");
        Thread thread2 = new Thread(client, "thread2");
        Thread thread3 = new Thread(client, "thread3");
        Thread thread4 = new Thread(client, "thread4");

        thread1.start();Thread.sleep(1);
        thread2.start();Thread.sleep(1);
        thread3.start();Thread.sleep(1);
        thread4.start();Thread.sleep(1);

    }

    @Override
    public void run() {

        try{

            reentrantLock.lock();

            String threadName = Thread.currentThread().getName();
            System.out.println(threadName + " running now");

            System.out.println(threadName + " exiting ");

        }finally{
            reentrantLock.unlock();
        }
    }

}

/*
    thread1 running now
    thread1 exiting
    thread2 running now
    thread2 exiting
    thread3 running now
    thread3 exiting
    thread4 running now
    thread4 exiting

 */

----------------------------------------------------------------------------------

Design Patterns
=======================

Creational Pattern                  Structural Pattern                      Behavioral Pattern
------------------------------------------------------------------------------------------------------
Singleton                                Proxy                                  Observer
Factory                                  Facade                                 Visitor
Prototype                                                                       Strategy
Builder

1. Singleton (Creational Pattern)
========================================

class Singleton {

    private static volatile Singleton singletonEx = null;

    // prevent Object creation by Constructor
    private Singleton() {
        // do nothing
    }

    // get Object instance by Double-check locking
    public static Singleton getSingleInstance() {
        if (Objects.isNull(singletonEx)) {
            synchronized (Singleton.class) {
                if (Objects.isNull(singletonEx)) {
                    singletonEx = new Singleton();
                }
            }
        }
        return singletonEx;
    }

    // prevent Object creation by Cloning
    @Override
    protected Object clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException();
    }

}


2. Factory (Creational Pattern)
====================================

interface Food {
	public String getType();
}

class Pizza implements Food {
	public String getType() {
		return "Someone ordered a Fast Food!";
	}
}

class Cake implements Food {

	public String getType() {
		return "Someone ordered a Dessert!";
	}
}

class FoodFactory {
	public Food getFood(String order) {
		if (order.equalsIgnoreCase("cake")) {
			return new Cake();
		} else if (order.equalsIgnoreCase("pizza")) {
			return new Pizza();
		}
		return null;
	}

}

public class FactoryEx {

	public static void main(String args[]) {

		try {

			Scanner sc = new Scanner(System.in);
			// creating the factory
			FoodFactory foodFactory = new FoodFactory();

			// factory instantiates an object
			Food food = foodFactory.getFood(sc.nextLine());

			System.out.println("The factory returned " + food.getClass());
			System.out.println(food.getType());
		} catch (Exception e) {
			System.out.println("Unsuccessful Termination!!");
		}
	}

}

3. Prototype (Creational Pattern)
====================================

Cloning
===============

Shallow clone :: referenced Object is shared     (Clone)
Deep clone    :: referenced Object is cloned     (Clone + set + Clone)


@Getter
@Setter
@AllArgsConstructor
@ToString
@NoArgsConstructor
public class Employee implements Cloneable{

    private int employeeId;
    private String employeeName;
    private Department department;

    //clone() has protected access in java.lang.Object
    @Override
    public Object clone() throws CloneNotSupportedException {
        //return super.clone(); //Shallow clone

        //Deep clone
        Employee employee = (Employee) super.clone();
        employee.setDepartment((Department) employee.getDepartment().clone());
        return employee;
    }
}

Department deptG = new Department(28383, "Geography", "Associate");
Employee empG1 = new Employee(111, "John", deptG); //prototype object

/*
Employee empG2 = (Employee) empG1.clone();
empG2.getDepartment().setDesignation("VP");
System.out.println("designation empG2 : " + empG2.getDepartment().getDesignation()); //VP
System.out.println("designation empG1 : " + empG1.getDepartment().getDesignation()); //VP
*/

//Deep clone
Employee empG3 = (Employee) empG1.clone();
empG3.getDepartment().setDesignation("VP");
System.out.println("designation empG3 : " + empG3.getDepartment().getDesignation()); //VP
System.out.println("designation empG1 : " + empG1.getDepartment().getDesignation()); //Associate

//Shallow clone a list
List<Employee> shallowCloneList = new ArrayList<>(empList);

//Deep clone a list
List<Employee> deepCloneList = empList.stream().forEach(emp -> {
Employee empClone = (Employee) super.clone();
empClone.setSkills(new ArrayList<>(empClone.getSkills().clone());
return empClone;
}).collect(Collectors.toList());

//Deep clone a list using mapstruct
@Mapper(mappingControl= Deepclone.class, componentModel="spring", unmappedTargetPolicy= ReportingPolicy.IGNORE,unmappedSourcePolicy= ReportingPolicy.IGNORE)
public interface ABCMapper{
	Set<Item> deeplCloneItems(List<Item> items);
}

4. Builder (Creational Pattern)
====================================
Fluid API
selective args

@Builder
User user = User.builder()
                .username("john_doe")
                .email("john@example.com")
                .age(30)
                .build();

5. Proxy (Structural Pattern)
==================================
Placeholder
Caching

public class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}
public class ProxyPatternMain {
    public static void main(String[] args) {
        Image image1 = new ProxyImage("image1.jpg");
        Image image2 = new ProxyImage("image2.jpg");

        image1.display(); // Image 1 will be loaded and displayed
        image2.display(); // Image 2 will be loaded and displayed

        // Image 1 is already loaded, so it will be displayed without loading again
        image1.display();
    }
}

6. Facade (Structural Pattern)
=================================

interface Mobile{
    String getModel();
    Integer getPrice();
}

class IPhone8 implements Mobile{

    @Override
    public String getModel() {
        return "Iphone 8";
    }

    @Override
    public Integer getPrice() {
        return 65000;
    }
}

class SamsungGT implements Mobile{

    @Override
    public String getModel() {
        return "Samsung Galaxy Tab 3";
    }

    @Override
    public Integer getPrice() {
        return 45000;
    }
}

class MobileFacade{
    IPhone8 iPhone;
    SamsungGT samsung;

    public MobileFacade(){
        iPhone = new IPhone8();
        samsung = new SamsungGT();
    }

    public String getIPhoneDetails(){
        return iPhone.getModel() + "--" + iPhone.getPrice();
    }

    public String getSamsungDetails(){
        return samsung.getModel() + "--" + samsung.getPrice();
    }
}

public class FacadeEx {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        String inputMobile = scanner.nextLine();
        MobileFacade mobileFacade = new MobileFacade();
        switch (inputMobile){
            case "samsung":{
                System.out.println(mobileFacade.getSamsungDetails());
                break;
            }
            case "iphone":{
                System.out.println(mobileFacade.getIPhoneDetails());
                break;
            }
            default:{
                System.out.println("NA");
            }
        }
    }
}

7. Observer (Behavioral Pattern)
====================================

/**
 *  Observer Design Pattern
 *
 *  behavioral design pattern that defines a one-to-many dependency between objects.
 *  When Observable changes state, all its Observers are notified and updated automatically.
 */
 @Getter
 public class TemperatureObservable extends Observable {

 	private int temperature;

 	//1.setChanged() / notifyObservers()
 	public void setTemperature(int temperature) {
 		setChanged();
 		notifyObservers();
 		this.temperature = temperature;
 	}

 	public static void main(String[] args) {
 		TemperatureObservable t0 = new TemperatureObservable();
 		//add observers to observable
 		t0.addObserver(new TemperatureObserver());
 		t0.addObserver(new TemperatureIceCreamObserver());
 		t0.setTemperature(12); //cold Ice Cream
 	}
 }

 class TemperatureObserver implements Observer{
 	@Override
 	public void update(Observable observable, Object arg1) {
 		if(observable instanceof TemperatureObservable temperatureObservable) {
 			int temperature = temperatureObservable.getTemperature();
 			if(temperature<=15) {
 				System.out.println("cold");
 			}
 			else if(temperature>15 && temperature<30) {
 				System.out.println("mild");
 			}else {
 				System.out.println("cold");
 			}
 		}
 	}
 }

 class TemperatureIceCreamObserver implements Observer{

 	@Override
 	public void update(Observable observable, Object arg) {
 		if(observable instanceof TemperatureObservable temperatureObservable) {
 			int temperature = temperatureObservable.getTemperature();
 			if(temperature<=0) {
 				System.out.println("Ice Cream");
 			}
 			else {
 				System.out.println("no ice cream");
 			}
 		}
 	}

 }

8. Visitor (Behavioural Pattern)
=================================

/**
 * Visitor Design Pattern
 *
 * behavioral design pattern that allows us to add further operations to objects without modifying their structure
 */

//Interface for all inventory items
//Each item will accept the Visitor
public interface Item {
    void accept(Visitor visitor);
}

@Data
@AllArgsConstructor
public class BookItem implements Item{
    private Double price;
    private Double weight;
    private String colour;

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

@Data
@AllArgsConstructor
public class FruitItem implements Item {
    private Double price;
    private Double weight;
    private String colour;

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

@Data
@AllArgsConstructor
public class ElectronicItem implements Item{
    private Double price;
    private Double weight;
    private String colour;

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

//Visitor will visit all the items
public interface Visitor {
    void visit(BookItem bookItem);
    void visit(FruitItem fruitItem);
    void visit(ElectronicItem electronicItem);
}

public class PriceVisitor implements Visitor{
    @Override
    public void visit(BookItem bookItem) {
        System.out.println("bookItem.getPrice() :: " + bookItem.getPrice());
    }

    @Override
    public void visit(FruitItem fruitItem) {
        System.out.println("fruitItem.getPrice() :: " + fruitItem.getPrice());
    }

    @Override
    public void visit(ElectronicItem electronicItem) {
        System.out.println("electronicItem.getPrice() :: " + electronicItem.getPrice());
    }
}

public class WeightVisitor implements Visitor{

    @Override
    public void visit(BookItem bookItem) {
        System.out.println("bookItem.getWeight() :: " + bookItem.getWeight());
    }

    @Override
    public void visit(FruitItem fruitItem) {
        System.out.println("fruitItem.getWeight() :: " + fruitItem.getWeight());
    }

    @Override
    public void visit(ElectronicItem electronicItem) {
        System.out.println("electronicItem.getWeight() :: " + electronicItem.getWeight());
    }
}

public class ColourVisitor implements Visitor{

    @Override
    public void visit(BookItem bookItem) {
        System.out.println("bookItem.getColour() :: " + bookItem.getColour());
    }

    @Override
    public void visit(FruitItem fruitItem) {
        System.out.println("fruitItem.getColour() :: " + fruitItem.getColour());
    }

    @Override
    public void visit(ElectronicItem electronicItem) {
        System.out.println("electronicItem.getColour() :: " + electronicItem.getColour());
    }
}

public class ShoppingCart {
    private List<Item> items = new ArrayList<>();

    public void addItem(Item item) {
        items.add(item);
    }

    public void applyVisitor(Visitor visitor) {
        for (Item item : items) {
           item.accept(visitor);
        }
    }
}


public class VisitorEx {

    public static void main(String[] args) {

        ShoppingCart cart = new ShoppingCart();
        cart.addItem(new BookItem(19.99, 1.2, "black"));
        cart.addItem(new FruitItem(2.99, 1.5, "red"));
        cart.addItem(new ElectronicItem(2.99, 1.5, "blue"));

        Visitor priceVisitor = new PriceVisitor();
        Visitor weightVisitor = new WeightVisitor();
        Visitor colourVisitor = new ColourVisitor();

        cart.applyVisitor(priceVisitor);
        cart.applyVisitor(weightVisitor);
        cart.applyVisitor(colourVisitor);

    }
}

/*
    bookItem.getPrice() :: 19.99
    fruitItem.getPrice() :: 2.99
    electronicItem.getPrice() :: 2.99
    bookItem.getWeight() :: 1.2
    fruitItem.getWeight() :: 1.5
    electronicItem.getWeight() :: 1.5
    bookItem.getColour() :: black
    fruitItem.getColour() :: red
    electronicItem.getColour() :: blue
*/


9. Strategy Design Pattern (Behavioural Pattern)
=======================================================
//change the behavior of an algorithm at runtime

interface Discounter{
    BigDecimal applyDiscount(BigDecimal input);

    static Discounter applyChristmasDiscount(){
        return input -> input.multiply(BigDecimal.valueOf(0.9));
    }

    static Discounter newYearDiscounter() {
        return amount -> amount.multiply(BigDecimal.valueOf(0.8));
    }

    static Discounter easterDiscounter() {
        return amount -> amount.multiply(BigDecimal.valueOf(0.5));
    }
}
public class StrategyDPEx {
    public static void main(String[] args) {
        BigDecimal priceAfterDiscount = Discounter.applyChristmasDiscount().applyDiscount(BigDecimal.valueOf(10));
        System.out.println(priceAfterDiscount);
    }


}
----------------------------------------------------------------------------------

Recursive
=============

Fibonacci numbers
----------------------

public int fibonacci(int n) {
  if(n <= 1) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
}

 0, 1, 1, 2, 3, 5, 8, 13, 21
 f(0) = 0
 f(1) = 1
 f(2) = 1
 f(3) = 2
 f(4) = 3
 
											f(4)
								
						f(3)	(2)								f(2) (1)    =3

					f(2)	f(1)							f(1)		f(0)						
					
				f(1)   f(0)	

----------------------------------------------------------------------------------

Dynamic Programming
===============================

Fibonacci numbers
----------------------

public int fibonacci(int n) {
  int[] memo = new long[n + 1];
  Arrays.fill(memo, -1);
  return helper(n, memo);
}

public int helper(int n, int[] memo) {
  if (n <= 1) {
    return n;
   }

  if (memo[n] != -1) {
    return memo[n];
  }       
  memo[n] = helper(n - 1, memo) + helper(n - 2, memo);
  return memo[n];
}

----------------------------------------------------------------------------------
